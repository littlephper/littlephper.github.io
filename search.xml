<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记录一次bug的解决过程]]></title>
    <url>%2F2018%2F05%2F19%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 在父组件中修改引入的字组件样式 参见这篇 https://blog.csdn.net/csdn_yudong/article/details/79087236 – 去掉scoped 在父组件的 &lt;style&gt; 中去掉 scoped 后，父组件中可以书写子组件的样式，但是你会担心这样会污染全局样式。因为我们知道正确使用全局样式的姿势是使用一个全局的 app.css – 混用本地和全局样式 你可以在一个组件中同时使用有作用域和无作用域的样式： 1234567&lt;style&gt; /* 全局样式 */ &lt;/style&gt; &lt;style scoped&gt; /* 本地样式 */ &lt;/style&gt; 我们把 需要修改子组件的样式 写在上面那个全局样式里面 – 使用深度作用选择器如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：12345&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */&#125;&lt;/style&gt; 有些像 SASS 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以用 /deep/ 操作符取而代之 —— 这是一个 &gt;&gt;&gt; 的别名，同样可以正常工作 2 背景(后台管理系统在点击已激活的路由时我们的功能是刷新当前路由, 且我们的三级路由页面是使用css样式覆盖在二级路由上面 就是说在进入三级路由后我们的二级路由页面并没有销毁) 发现问题在其中涉及到的创建以及编辑类的三级路由页面 由于保存成功后需跳转回二级路由页面且同时刷新二级路由页面 起初我们的的代码是这样的 12345678910111213141516171819202122232425// 在二级路由created周期内created ()&#123; // 这里是请求数据函数 dosomething Bus.$on(&apos;刷新二级路由事件&apos;, callback)&#125;// 起初在二级路由的beforeDestrory阶段Bus.$off(&apos;刷新二级路由事件&apos;, callback) 但我们的二级路由并没有销毁 所以gg// 后再watch中监控$routewatch:&#123; &apos;$route&apos;: function()&#123; Bus.$off(&apos;刷新二级路由事件&apos;, callback) &#125;&#125;// 以上中由于中间callback的各次变更不同 遇到的bug 造成的效果基本大致是相同的 此处选择代表性的// 在三级路由页面保存成功后this.timer = setTimeout(() =&gt; &#123; this.$router.back() clearTimeout(this.timer)&#125;, 500);beforeDestroy ()&#123; Bus.$emit(&apos;刷新二级路由事件&apos;, callback)&#125; 咋一看逻辑毫无毛病,但后期测试妹子在操作时发现经常性出现请求超时 network打开后跳转回第二页时,竟发送多次请求. 通过多种情况打印时间戳发现,由于我们是点击已激活路由(看背景),造成了二级路由的多次渲染即created中多次执行 Bus.$on(&#39;刷新二级路由事件&#39;, callback) 绑定了多次,当路由切换时Bus.$off(&#39;刷新二级路由事件&#39;, callback)执行,但我们无法确定是否执行了几次,毕竟离开当前路由和进入当前路由时watch都是可能触发的 解决过程:此时我们再翻vue的文档(vue的文档真良心!) vm.$off( [event, callback] )参数：{string | Array} event (只在 2.2.2+ 支持数组){Function} [callback]用法： 移除自定义事件监听器。1 如果没有提供参数，则移除所有的事件监听器；2 如果只提供了事件，则移除该事件所有的监听器；3 如果同时提供了事件与回调，则只移除这个回调的监听器。 此时通过文档第三项 我们可以稍微理解为只要走了watch 那必然触发打印watch内的时间戳 则Bus.$off也是要走的 然并卵 此时祭出vue源码 12345678910111213141516171819202122232425262728293031323334353637383940Vue.prototype.$off = function (event, fn) &#123; var this$1 = this; var vm = this; // all if (!arguments.length) &#123; vm._events = Object.create(null); return vm &#125; // array of events if (Array.isArray(event)) &#123; for (var i = 0, l = event.length; i &lt; l; i++) &#123; this$1.$off(event[i], fn); &#125; return vm &#125; // specific event var cbs = vm._events[event]; if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null; return vm &#125; if (fn) &#123; // specific handler var cb; var i$1 = cbs.length; while (i$1--) &#123; cb = cbs[i$1]; if (cb === fn || cb.fn === fn) &#123; cbs.splice(i$1, 1); break // 此处 当绑定的事件数组大于0时则splice一次(即去掉一次事件)就退出循环 由此可见仅且$off掉一次已绑定事件 &#125; &#125; &#125; return vm&#125; 由于我们多次点击已激活路由造成多次$on同一个callback 然而只$off了一次 解决办法:不使用Bus 在三级路由页面销毁时直接使用 1234beforeDstroy()&#123; this.$parent.method // method为在父组件中定义的请求数据方法&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用富文本编辑器]]></title>
    <url>%2F2018%2F05%2F19%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1 百度Ueditor 编辑器组件封装如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;template&gt; &lt;div&gt; &lt;script id=&quot;editor&quot; type=&quot;text/plain&quot;&gt; &lt;/script&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 先从官方文档上下载需求版本放置在static文件夹下 文件上传地址按文档配置说明 其中config.js中URL使用/static/path/ueditor // 此处在webpack中.config中设置externals UE:UE // 或者直接import引入四个必备js // import UE from &apos;UE&apos; export default &#123; name: &apos;UE&apos;, props: &#123; content: &#123; type: String, default: &apos;&apos; &#125;, id: &#123; type: String, default: &apos;editor&apos; &#125; &#125;, data () &#123; return &#123; UE: &apos;&apos; &#125; &#125;, mounted () &#123; setTimeout(() =&gt; &#123; this._initEditor() &#125;, 500) &#125;, methods: &#123; _initEditor () &#123; this.UE = UE.getEditor(this.id) &#125;, // 获取编辑器内容 getEditorContent()&#123; return this.UE.getContent() &#125;, // 检查编辑器中是否有内容 hasEditorContent () &#123; return this.UE.hasContents() &#125; // 禁用编辑器 unableEditor ()&#123; this.UE.setDisabled() &#125; &#125;, watch: &#123; content: function (val) &#123; // 监测传入的数据 UE.getEditor(&apos;editor&apos;).ready(() =&gt; &#123; if (val) &#123; this.UE.setContent(val) &#125; else &#123; this.UE.setContent(&apos;&apos;) &#125; &#125;) &#125; &#125;, beforeDestroy () &#123; this.UE.setContent(&apos;&apos;) // 组件销毁的时候 也销毁编辑器 顺便清空编辑器内容 if (this.UE !== null &amp;&amp; this.UE.destroy) &#123; this.UE.destroy() &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt; tips: 在清空编辑器内容时你可能会遇到 lastChild of undefined 的错误, 那么在ueditor.all.js中将autoheight功能代码注释掉不想频繁的自动保存的话就把autosave模块注释掉如果遇到scrollTo of undefined错误,在源码 else if后面的判断句中添加&amp;&amp;!me12345678910//修复内容过多时，回到顶部，顶部内容被工具栏遮挡问题 var lastScrollY; window.onscroll = function()&#123; if(lastScrollY === null)&#123; lastScrollY = this.scrollY &#125;else if(this.scrollY == 0 &amp;&amp; lastScrollY != 0)&#123; me.window.scrollTo(0,0); lastScrollY = null; &#125; &#125; 2 富文本编辑器 wangEditor3(个人开发者维护) –github地址: wangEditor3 – 文档地址: wangEditor3文档 1、直接采用npm安装 2、通过import方式直接引入使用 3、封装单独组件时需注意引入的props要watch后设置才可(获取周期) 4、在单页面中且需要自定义尺寸时 建议上部菜单栏及下方编辑区分离 且使用ref方式 如下 123456789101112131415161718192021222324252627282930//tempalte&lt;div class=&quot;editor&quot;&gt; // 顶部菜单栏 &lt;div ref=&quot;editor_toolbar&quot; class=&quot;editor_toolbar&quot;&gt; &lt;/div&gt; // 下方编辑区 &lt;div ref=&quot;editor_content&quot; class=&quot;editor_content&quot;&gt; &lt;/div&gt;// scriptimport E from &apos;wangeditor&apos;...// 在mounted中初始化编辑器this.editor = new E(this.$refs.editor_toolbar, this.$refs.editor_content)// 由于需要监控可能传入的值 此时需要onchange以及change方法this.editor.customConfig.onchange = (html) =&gt; &#123; this.$emit(&apos;changeContent&apos;, html)&#125;this.editor.create()// this.editor.txt.html(this.content)// change方法请务必在编辑器初始化后添入this.editor.change()// 属性传值时需 watchwatch: &#123; content(val) &#123; this.editor.txt.html(val) &#125;,&#125;// 以及可添加编辑器禁用和启用属性 5、当前版本未提供编辑器销毁api (“wangeditor”: “^3.1.1”) 6、其中上传图片this.editor.customConfig.uploadImgUrl = &#39;接口&#39; 不使用文档中的 uploadImgServer 另根据后台约定定义上传文件的fileName 7、其他配置参见文档]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
